 <!-- Размещаем input для фильтрации данных. 
    Мы хотим, чтобы мы вписывали в input какой-то текст, в нашем случае это текст, который будет фильтровать по имени,
    т.е. мы будем вписывать в поле имя Angie и покажется только карточка этого юзера.
    Это реализуем с помощью пайпов.
    Для начала нам нужно считать инфо, кот. хранится в input. В пайп нам нужно передавать текущее состояние input.
    Для этого можно воспользоваться либо call back, повесить на input повесить событие input и считывать по event target различные состояние input,
    либо воспользоваться two way binding (двусторонняя привязка) - мы можем данному input добавить ngModel,
    кот. будет автоматически следить за изменениями внутри шаблона и внутри компонента за определенным полем.
    Добавляем в input [(ngModel)], где ngModel название, и сюда будем передавать переменную, напр. searchStr. (1 шаг - создание пайпа)

    Данную переменную searchStr необходимо создать в app.component.ts (потому что мы работаем именно в его шаблоне app.component.html)
    в классе AppComponent. (2.0 шаг - создание пайпа).

    ng модель работает таким образом: мы будем что-то в input вписывать и сразу же автоматически данное значение
    будет находиться в переменной searchStr. Именно для этого у нас используется two way binding.
    -->
    <div class="row">
      <div class="input-field col s6">
          <input id="first_name" class="validate" [(ngModel)] = "searchStr">
          <label class="active" for="first_name">Поиск по имени</label>
      </div>
  </div>

  <div class="row">
      <!-- нам нужно в цикле провести app-user (используем цикл for/of(появился в ES6) внутри шаблона), 
      * - дирректива, которая будет менять html. На каждую из итераций цикла нужно создать переменную.
      Создаем переменную с помощью ключевого слова let и пишем ее название, напр. u.
      Далее указываем откуда мы эту перемнную берем: of users (users - название массива из AppComponent).
      В синтаксисе мы говорим, что на каждой итерации, для каждого из элементов данного массива мы будем создавать переменную user,
      т.е. на каждой итерации переменная user будет являться данным объектом {name: 'WFM 1'}. (2 шаг - вывод списка элементов) -->

      <!-- Нам нужно передавать различные данные в компонент. В user.component.html в span прописан статический текст для карточек.
      Но мы хотим передавать имя, которое, мы давали для каждого из элементов в массиве users в app.component.ts.
      Данную переменную user мы хотим передать внутрь данного компонента <app-user>.
      В user.component.ts в классе отмечаем, что мы ожидаем что-то входящее в данный компонент с помощью спец. конструкции:
      @Input() user (указываем, что input данного компонента мы кладем в переменную user) (3.0 шаг - вывод списка элементов) -->

      <!-- Чтобы указать Angular, что u это объект, а не строка используем one way binding (односторонняя привязка) свойство.
      Т.е. мы должны следить за какими-то переменными. [user] мы кладем в квадратные скобки и 
      т.о. говорим, что user, это не просто атрибут, а целый объект, который мы передаем в наш компонент.
      Теперь в каждом компоненте app-user у нас будет доступна переменная u.
      Переменная u будет попадать в локальную переменную user (в user.component.ts) и для того, чтобы к ней обратиться,
      в шаблоне user.component.html в span обратимся к ней с пом. такой конструкции {{ user.name }}. Теперь название каждой карточки уникально.
      Вкратце, что происходит: на каждой итерации мы создаем переменную u, путем пробегания по массиву users
      и для того, чтобы передать данную переменную в компонент (в тег <app-user>), мы говорим Angular,
      что [user] будет каким-то динамическим свойством. И в [user] мы кладем объект u.
      А в компоненте user.component.ts c пом. декоратора @Input мы говорим, что ожидаем user.
      И теперь в user.component.html мы можем использовать данное свойство. (4 шаг - вывод списка элементов) -->
      <app-user
      *ngFor = "let u of users | search:searchStr"  
      [user]="u"
      ></app-user>
      <!-- мы делаем итерацию по массиву users и тут применяем пайп через | 
      Данный пайп должен принимать значение value, передаем ему searchStr.
      Теперь поиск и фильтрация готовы. (15 шаг - создание пайпа) --> 
  </div>

<!-- После создания 2-х новых компонентов home-page.component и setup-page.component необходимо все перенести
из app-component в home-page.component:
из app-component.html перенести всю разметку сюда (в home-page.component.html);
из app.component.ts (из export class AppComponent) нужно скопировать все поля в home-page.component.ts
(в export class HomePageComponent implements OnInit).
Также в home-page.component.ts нужно подключить UsersService путем импорта из файла '../users.service'.
Теперь компонент становится валидным.
В app.component.ts нужно оставить регистрацию UsersService, чтобы он работал.
Добавляем в app.component.html (основной шаблон) навигацию (она будет общаяя для всего приложения)
и создаем роуты в app.module.ts с пом. константы. -->
