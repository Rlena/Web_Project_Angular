import { Component, OnInit } from '@angular/core';
import { UsersService } from '../users.service';

@Component({
  selector: 'app-home-page',
  templateUrl: './home-page.component.html',
  styleUrls: ['./home-page.component.scss']
})
export class HomePageComponent implements OnInit {

  users = [];
  

 // переходим в app.module и в массиве imports добавляем FormsModule, кот. импортируется из библиотеки '@angular/forms'

 searchStr = ''   /* создаем переменную searchStr, по умолчанию она будет являться пустой строкой. (2.1 шаг - создание пайпа)
                  Eсли мы пользуемся two way binding, т.е. ngModel, то нам также нужно зарегистрировать определенный модуль,
                  чтобы он поддерживал работу данного функционала. Мы переходим в app.module.ts и в массиве imports добавляем FormsModule.
                  (2.2 шаг - создание пайпа) */
  
 /* мы инжектим некоторые сервисы в наш компонент с помощью данной конструкции,
 после этого он у нас доступен и мы можем обращаться к его различным полям.  (5 шаг - создание сервиса)
 Теперь в user.service.ts нам нужно сделать запрос на удаленный сервер. (1.0 шаг - запрос на удаленный сервер)  */

 constructor(private usersService: UsersService) {}     /* Подключение сервисов в компоненты:
                                                        UsersService нужно подключить в компоненте.
                                                        Обращаемся к конструктору, создаем приватную переменную UsersService,
                                                        которая будет являться типом UsersService. (2.1 шаг создание сервиса)
                                                        Теперь нужно импортировать данный сервис
                                                        из файла './users.service' (2.2 шаг - создание сервиса) */
 
 ngOnInit() {  /* в Angular есть специальные callback (функция обратного вызова), которые отвечают за жизненный цикл компонента,
               один из которых ngOnInit, принято различные присвоения данных делать в данном компоненте,
               constructor при этом остается для инжекта Inject (вводить) */

 /* Здесь мы обращаемся к переменной this.users. В ней хранится теперь сервис UsersService и мы обращаемся к его полю users.
 Заносим в переменную users значение массива, который у нас лежит в сервисе UsersService (user.service.ts). (4 шаг - создание сервиса) */
 // this.users = this.UsersService.users

  /* у нас есть приватный массив users и все, что мы сделаем в данном методе, мы должны переопределить данный пустой массив,
  для того, чтобы мы вывели его в цикле  */ 
    this.usersService.getUsers().subscribe(users=> {   /* обращаемся в сервису usersService, к его методу getUsers.
                                                       (3.1 шаг - запрос на удаленный сервер)
                                                       Теперь в user.service.ts перед классом UsersService нужно поставить декоратор @Injectable().
                                                       (4.0 шаг - запрос на удаленный сервер)
     
                                                       если мы не подписываемся на стрим (а как раз-таки http-объект возвращает нам RXjs stream),
                                                       то он не будет делать запрос, т.е. мы обязательно должны пописаться на данный запрос,
                                                       чтобы он выполнился. 
                                                       Мы уже работаем со стримом, это обычный стрим библиотеки RXjs.
                                                       Он возвращается у нас в результате работы данного метода this.usersService.getUsers(),
                                                       поэтому мы можем подписаться на данный стрим с помощью функции subscribe().
                                                       Сюда мы будем принимать некоторый массив users. (7 шаг - запрос на удаленный сервер)
                                                       Теперь нужно обработать ответ сервера в users.service.ts в getUsers() (т.к. с сервера
                                                       данные приходят в неудобном для нас формате). (8.0 шаг - запрос на удаленный сервер) */

       this.users = users  /* У нас есть пустой приватный массив users = [] и мы должны переопределить данный пустой массив,
                           для того, чтобы мы вывели его в цикле:
                           this.users переопределяем на тех юзеров, которые приходят нам в методе subscribe.
                           (9.1 шаг - запрос на удаленный сервер) 
                           После этого переходим в user.component.html. Теперь мы знаем, что у каждого юзера есть поле image,
                           поэтому в src указываем {{ user.image }}.
                           И как параграф меняем на {{ user.geo }}.
                           Теперь у каждой карточки подгружается уникальная картинка. (10 шаг - запрос на удаленный сервер) */
    })
 }

}
