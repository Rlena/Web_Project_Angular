import { Pipe, PipeTransform } from "@angular/core"; /* импортируем декоратор Pipe (5.3 шаг - создание пайпа) */

@Pipe({  /* вешаем декоратор.
         декоратор @Pipe говорит Angular, что данный класс является пайпом (5.1 шаг - создание пайпа)
         Импортируется декоратор из библиотеки "@angular/core". (5.2 шаг - создание пайпа)
         В конфигурацию данного декоратора мы передаем объект, у него есть обязательное поле name с названием пайпа, 
         напр. search (5.4 шаг - создание пайпа) */

    name: 'search'
})

/* у каждого пайпа должен быть реализован метод transform таким образом:
этим классом SearchPipe имплементироваться от спец. класса PipeTransform, интерфейс также импортируется из библиотеки '@angular/core'.
И теперь нужно реализовать функцию transform, именно для этого существует данный интерфейс PipeTransform
(чтобы мы знали какие методы нам нужно имплементировать (осуществлять, реализовывать)). (6 шаг - создание пайпа) */

export class SearchPipe implements PipeTransform { /* пайп создается как обычный typeScript файл в папке app,
                                                  и это опять же обычный класс. (4 шаг - создание пайпа)
                                                  Нужно повесить спец. декоратор @Pipe. (5.0 шаг - создание пайпа) */

   transform(users, value) {  /* первым параметром метод transform() массив users, вторым параметром значение value,
                              т.е. то что у нас сейчас хранится в input.
                              Из данного метода нам нужно вернуть новый массив уже отфильтрованный. (7 шаг - создание пайпа) */

    return users.filter(user => { /* Для этого делаем return, верну что-то, далее обращусь к user
                                  и с помощью его метода filter отфильтрую данный массив.
                                 (Mетод filter возвращает нам новый массив, который уже по каждой переменной применяет какое-либо условие,
                                 т.е. если условие было соблюдено и оно возвращает нам true, то соответственно элемент в массиве остается,
                                 если же нет, он убирается у нас из результирующего массива.)
                                 В метод filter мы передаем call back, где на каждой итерации мы будем принимать переменную user.
                                 (8 шаг - создание пайпа) */

        return user.name.includes(value) /* и здесь мы должны вернуть условие.
                                         /* мы будем обращаться к переменной user и к ее полю name и далее с помощью метода includes
                                         (который позволяет нам проверить есть у строки определенное значение)
                                         мы будем проверять на строку value, которая нам будет возвращаться. (9 шаг - создание пайпа)
                                         Теперь pipe нужно зарегистрировать в app.module.ts в массиве declarations. (10 шаг - создание пайпа) */
       })
    /* т.о. мы принимаем сюда массив юзеров, это все оригинальные пользователи, которые у нас есть,
    далее в input мы будем получать некоторые value, которые также нам будут поступать в pipe.
    После этого мы фильтруем массив юзеров, где на каждой итерации мы получаем объект юзера.
    У каждого из объектов юзера есть поле name строковое и у строки мы вызываем метод includes, куда мы передаем название того значения,
    которое у нас сейчас находится в input, и если оно возвращает true, то это означает, что да действительно в имени содержится это слово
    и оно должно у нас быть в результирующем списке. */
   }
}