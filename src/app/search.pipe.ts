// без пайпа пока нет никакого функционала по поиску элементов
// пайп создается как обычный typeScript файл в папке app, и это опять же обычный класс

import { Pipe, PipeTransform } from "@angular/core";

// декоратор @Pipe говорит Angular, что данный класс является пайпом
// в конфигурацию данного декоратора мы передаем объект, у него есть обязательное поле name
@Pipe({
    name: 'search'
})
// у каждого пайпа должен быть реализован метод transform таким образом:
// этим классом SearchPipe имплементироваться от спец. класса PipeTransform, интерфейс также импортируется из библиотеки '@angular/core'
// и теперь нужно реализовать функцию transform, именно для этого существует данный интерфейс PipeTransform (чтобы мы знали какие методы нам нужно имплементировать (осуществлять, реализовывать))
export class SearchPipe implements PipeTransform {
   /* первым параметром метод transform() массив users, вторым параметром значение value, т.е. то что у нас сейчас хранится в input
    из данного метода нам нужно вернуть новый массив уже отфильтрованный,
    для этого делаем return, верну что-то, далее обращусь к user и с помощью его метода filter отфильтрую данный массив
    метод filter возвращает нам новый массив, который уже по каждой переменной применяет какое-либо условие,
    т.е. если условие было соблюдено и оно возвращает нам true, то соответственно элемент в массиве остается,
    если же нет, он убирается у нас из результирующего массива.
    В метод filter мы передаем call back, где на каждой итерации мы будем принимать переменную user и здесь мы должны вернуть условие */
   transform(users, value) {
       return users.filter(user => {
        /* мы будем обращаться к переменной user и к ее полю name и далее с помощью метода includes (который позволяет нам проверить есть у строки определенное значение) мы будем проверять на строку value, которая нам будет возвращаться */
        return user.name.includes(value)
       })
    // т.о. мы принимаем сюда массив юзеров, это все оригинальные пользователи, которые у нас есть, далее в input мы будем получать некоторые value, которые также нам будут поступать в pipe. После этого мы фильтруем массив юзеров, где на каждой итерации мы получаем объект юзера. У каждого из объектов юзера есть поле name строковое и у строки мы вызываем метод includes, куда мы передаем название того значения, которое у нас сейчас находится в input, и если оно возвращает true, то это означает, что да действительно в имени содержится это слово и оно должно у нас быть в результирующем списке

    // pipe надо также зарегистрировать в app.module в массиве declarations
   }
}